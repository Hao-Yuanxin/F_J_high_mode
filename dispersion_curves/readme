Love_dispersion.m
计算理论的Love波频散曲线。
界面的编号和层的编号与Xiaofei Chen(1993)，
A systematic and efficient method of computing normal modes for multilayered half-space 一致
参数设定：size ：z_bottom (N,N>=1)  （最下面一层到无穷远，没有界面）；size z_bottom rho beta alpha miu (N+1) 
c_love_min，速度搜索的最小值，要小于beta的最小值
c_love_max，速度搜索的最大值，要大于beta的最大值
delta_c,c的搜索步长，搜索步长要小一些，长度要小于两个根之间的距离，也要小于半个波形。
这里我取0.001，因为0阶对应的波形非常窄。（T =1s时，当delta_c取0.01，会漏掉基阶）
但是仍然在f=1.8的时候漏掉了基阶，引入delta_small_c

delta_small_c = 0.0001 
寻找计算起点时的步长，同时也是前5个根时的步长，因为第一个波形变化非常剧烈，非常窄，并且随着frequency增加，波行会更窄
计算起点时的步长设为0.0001，就不会漏掉基阶。
求前5阶的根的步长设成0.0001。

Epsilon，一个小量，设为10^（-6）

mode_number,面波的阶数（0阶开始，最高阶为mode_number-1阶）。
f = 4Hz时，有41个根；f = 5Hz时，有51个根。因此将mode_number设为40；
f_all,研究的频率范围(Hz)，这里我设定成0.1：0.1：5(频率不能为0，否则无法计算);w_all,f_all对应的角频率，用于计算。

久期函数函数secular fuction == 0时,此时的（w，vn）就是对应的频散，n=0,1,2...,代表阶数。
所以问题变成了求久期函数的零点（虚部的根同时为实部的极小值）。
1. secular_w_c=SECULAR（w，c）
计算久期函数
输入单个频率w和单个速度c，计算对应的久期函数值secular_w_c
公式来源于陈晓非1993年的文章。可以结合张海明的理论地震学的均匀无限半空间的格林函数来理解
1.根据基函数（Hansen矢量）展开的系数为零建立其次方程组。
2.为了降阶引入位移牵引力矢量。
3.每一次的位移牵引力矢量的其次解的一般形式已知，其中C是待定系数，其余都可以求得。
4.求得每一层的反射透射矩阵。
5.通过最下面一层的广义反射透射矩阵，从下到上迭代求解出所有层的广义反射透射矩阵。
6.然后利用广义反射透射矩阵，得到secular function。
#利用广义反透射系数可以求得每一层的待定系数C，最后求得位移，本代码只求频散，并不会用到待定系数C。
#当c与各层的beta值相等时，会出现NaN，那么出现c == beta（j）（j是层号）的情况就给c加个小量Epsilon（1*10^-6)。


2.function c_begin = find_begin(w0)
久期函数为零，实部虚部的都为零，对于虚部来说，零点是根；对于实部来说，零点时极小值。
所以这里用虚部求根，然后结合实部判断是否为零值。
值得注意的是，虚部在（cmin，beta_min）之间为零，因此需要用本函数来寻找第一个不为零(abs(x)>0.1)的点作为搜索根的起点。
因为出现了漏掉基阶的情况，起点设为betamin,步长delta_small_c设为0.0001；

3.[root,x_right]=root_1(w0,c_start) 
求w=w0时的，久期函数的虚部的1个根，（虚部的根对应着实部的极大值或者极小值,因此这个根可能不是要求的零点） 
引入步长参数，step。因为久期函数的基阶非常窄，防止漏掉基阶的根，需要将基阶的步长设置为0.0001。但是考虑计算效率，高阶的步长要设为0.001
因为一个频率对应着多个根，因此需要确定每一个根的区间。
输入的c_start是搜索当前的根的起点，然后输出的x_left，是这个根的右边界，也是这一次搜索的终点，（作为下一次搜索的起点）。
那么根所在区间就是（x_left-delta_c,x_left).
若root == x_right，那么可能会出现有两个相同大小的根的情况，为了避免，需要给 x_right加个小量，x_right = x_right + Epsilon * 10(10^-5次方就差不多会被认为一个点)
要考虑到c_temp大于定义的速度最大值c_love_max的情况，要把搜索区间缩小，不能超出范围，即使得用于计算的c_temp = c_love_max，
然后再判断新的区间有没有根。
返回值x_right不用改，求w0对应的所有根的时候，x_right用于判断是否终止迭代。
x_right为空或者x_right > c_love_max，就不会去求下一个根
找到根的区间，用弦截法迭代求根。
弦截法，根在（x1，x2）之间，将两点坐标连线，得到一个根（对应的横坐标为t），令x1 = x2； x2 = t；
直到满足条件（满足迭代次数或者满足收敛判断）

4.function root_all = findroot_all(w0)
输入频率w0，返回值是对应的速度值。
1.用 find_begin(w0)求得起点
2.求得虚部的根
3.判断虚部的根是否为实部的极小值（real< 0.3，稍微取大一点，防止漏掉根）
3.判断迭代是否继续
没有根，结束
根的右边界超出c_love_max，本次迭代完成后结束；（若c_love_max > beta_max + delta_c ,那么这一次不会有根，delta_c是搜索步长)。

5.function V_M = get_V_M(w_all)
N_w表示w_all的长度
V_M,速度矩阵，有N_w行，每一行对应着一个频率;有mode_number列，每一列对应着该阶的速度值。
给定频率范围，得到速度矩阵
高阶面波有截止频率，随着频率的增加，阶数越来越多。
所以V_M矩阵右上角有倒三角的空缺，用零表示（0在这里并不是零值，而是表示没有，所以输出的时候需要判断一下是不是非零）。

6.function plot_write_Love_dispersion(file_name)
file_name,生成的文件，最好是绝对路径
会生成Love波频散，写在文件里并画图。
通过看频散曲线，可以直观的看到结果是否正确。
若出现不平滑，则找到对应的频率，在主函数中更改w，通过久期函数的图像和根，找问题的来源。

常见问题有
1.漏掉根，由于frequency的增加，导致久期函数变化剧烈，漏掉根。可以通过缩小步长解决。
（本程序中，前五阶的步长是0.0001，更高阶是0.001,在function root_all = findroot_all(w0)里改）
2.重根，求根的时候，根离右边界非常近，导致被认为是一个点，出现在两个求根区间，同样的根出现两次，导致阶数错断。
这里我设置当两个点相差小于10^-5，右边界右移10^-5，在function root_all = findroot_all(w0)里改
3.没识别根，虚部求根时，实部是极小值，这个极小值理论上是零，但计算中会有偏移，再加上根的解也有误差，如果久期函数波形变化很剧烈的话，
可能实部距离0比较远。因此需要选定一个范围，这里我设置的是（abs（x))小于0.3，在function root_all = findroot_all(w0)里改。
4.第一个根不正确
因为要先求取久期函数虚部的根，而虚部在开头的一段值为零。所以需要先找到一个不为零的点A0作为起点。
这里涉及到两个参数，一个是步长，如果步长过大，容易跳过去漏掉第一个点，其实计算量不大，步长可以设小点（这里我设的0.0001）
5.函数图像与根不吻合
主程序的图中，看函数图像没根，但是绘制了root点，这不一定说明求取的根是错误的。
可能是函数图像自变量的间隔小，而久期函数变化的剧烈，不满足采样定律，可以减少间隔。
6.其他
涉及到取值边界，即搜索时超出设定范围（已解决)
大概想到这么多
格式 
！ 说明文字，好几行
#  阶数  
frequency   (1行，虽然有时候显示两行，但实际是一行，这里有个潜在的问题，如果输出的数据很多，超过一行，那么需要自己修改函数6）
velocity   （1行，与上面的frequency对应）

















