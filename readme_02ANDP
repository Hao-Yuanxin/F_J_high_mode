
/home/steven/test/Code-FanXL/ANT-Code/01*
测试FanXL的处理数据的脚本，其中有数据文件

/home/steven/test/Code-FanXL/ANT-Code/02*
 Fortran代码,包含串行和并行两个版本,
 参考Barmin 背景噪声数据处理算法(http://ciei.colorado.edu/Products/)


./Code-FanXL/ANT-Code/02_ANDP/Sequential 串行
执行./ANT-Code/02_ANDP/Sequential/TEST/目录下的Compile.sh
1.cd ../SRC/AFTAN
2.make
 makefile
 all: addition.mod
 addition.mod 伪目标（这里没有显式的声明 .PHONY : all）
 addition.mod: addition.f90
	$(FC) -c $^
 $^ ,自动化变量: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份
 fflags = -O -Wall -ffixed-line-length-none
 FFLAGS = $(DBG) $(fflags)
 FC = gfortran
 DBG = -g
 LDLIBS =  -lfftw3
 FOBJS = driver.o swapn.o aftanpg.o aftanipg.o addition.o ftfilt.o fmax.o taper.o trigger.o     tapers.o tgauss.o mspline.o pred_cur.o misc.o phtovel.o

 $(BIN) : $(FOBJS)
	$(FC) $(FFLAGS) $(FOBJS) -o $(BIN) $(LDLIBS)
 fortran 编译器选项 https://docs.oracle.com/cd/E19205-01/820-1206/aevcv/index.html
 DBG = -g，Debug选项；-O[n]表示优化级别，-O就等于-O3(O是大写的O，不是0);-W[n]，显示错误信息，这里all应该是W4
 -ffixed-line-length-none 不限语法的长度，f90默认一行不超过132
  -lname ，链接库，这里链接 -lfftw3
 $(FC) $(FFLAGS) $(FOBJS) -o $(BIN) $(LDLIBS)
 因为隐含规则，会自动的从.o文件推导出依赖的.f
 install :: $(BIN)
 变量多加一个：变成静态的，只能使用前面已定义好了的变量，用于变量中的变量
 clean把编译的.o和.mod文件都删了
 cleanall执行了clean，并且删除了可执行文件$(BIN)
3.make install
 将可执行文件AFTAN_PROG放在此目录下INST_DIR = /usr/local/bin
4.make cleanall
 就剩下/usr/local/bin的可执行文件AFTAN_PROG
5.cd ../AND_Driver
 进入AND_Driver
6.和上面步骤一样，make cleanall ；make ；sudo make install； make cleanall
 makefile
 %.o: %.f90
	$(FC) -c $^
 定义规则模式，从.f90编译出.o
 在INST_DIR = /usr/local/bin/下生成AND_Driver程序
  
 配置输入文件参数
 /Sequential/TEST/input.dat

 执行Run.py

#####################################################################################################################
全局变量                    描述                值                                               定义的位置
SGL，                     单精度，          vlaue=4,                           MODULE addition(AFTAN/addition.f90)
DBL，                     双精度，          vlaue=8,                           MODULE addition(AFTAN/addition.f90)
type(sac_d) 包含 TYPE(event),TYPE(station),TYPE(record),INTEGER :: nev, nst   MODULE my_definition(AND_Driver/my_definition.f90)
TYPE(station)        name 台站名, n_name台网名, lat,lon                        MODULE my_definition(AND_Driver/my_definition.f90)
TYPE（event）    CHARACTER,name;INTEGER yy, mm, dd, h, m, jday;REAL(SGL) s    MODULE my_definition(AND_Driver/my_definition.f90)
TYPE(record)  CHARACTER,name;CHARACTER,channel;REAL(DBL),t0;

 
type(sachead) sac头文件，对照SAC手册      ##                                    module sac_io(AND_Driver/sac_io.f90)


##################################################
##################################################
AND_Driver
##################################################
主程序 AND_Driver.f90
USE Main_Proc 调用了Main_Proc MODULE



######################################
######################################
AFTAN_PROG
#########################
主程序 driver.f
	nargc = iargc()   # nargc是执行编译后的driver.o时的参数个数
	if(nargc.ne.1) then
 		stop      # .ne. 是不等于，参数个数不等于1，程序停止

open(unit=99, file='input.dat', status='old')  # status='old',打开已经存在的文件 跳过input.dat前17行
      do k = 1, 17
          read(99,"(a)") cmd     # format：a[n] a代表字符，n代表数目，什么都不加就是读入一行
      end do

INPUT PARAMETERS FOR AUTOMATIC FREQUENCY-TIME ANALYSIS,
读入自动时频分析的参数，此时已经有了互相关结果
call getarg(1,cmd)
将命令的第一个参数赋给cmd,我还不知道命令的参数是什么，但知道是个./（TEST）下的文件名
 read(10,'(a)',end=2) name   #end = 2，读到文件末尾时，跳到行代号是2的语句，
这里是个循化，读完最后一行跳到end=2，2对应的命令是程序结束






 addition.f90
************************
 MODULE addition
 子程序
 SUBROUTINE write_data(array1, nfout1, array2, nfout2, filename)
 array1，原始测量矩阵， nfout1，原始测量矩阵的列
 array2,clean 矩阵， nfout2，clean 矩阵的列
 array1, nfout1, array2, nfout2, filename都是只读的INTENT(IN)





 




