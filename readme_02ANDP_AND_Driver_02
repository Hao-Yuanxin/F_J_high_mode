###############################################################################
AND_Drive

part 02                # line number 241
去仪器响应(去均值，去趋势，去仪器响应，输出sac是速度谱)，截取地震记录(t0,tlen,写在input.dat)，并且写入 tarfolder/DATA_VEL/年/月/日期下
删除复制后的SAC文件夹(rm -rf '//TRIM(tarfolder)//'/DATA') # 将原始数据复制到DATA文件夹下，将处理后的SAC放入DATA_VEL下，删除DATA文件夹
***********************************************************************************************************************

循环事件，台站
str_temp = 文件路径 tarfolder/DATA_VEL/年/月/日期/文件  # part 02处理后的SAC文件路径
INQUIRE(FILE=str_temp, EXIST=alive)，判断文件是否存在，存在alive是T,说明已经处理完了，CYCLE(等于C里面的continue，跳过此次循环)
str_temp = 日期文件夹 
CALL remove_RESP(sdb, iev, ist, f1, f2, f3, f4)          # MODULE Main_Proc
将tarfolder下的SAC复制到当前目录/temp.sac,对temp.sac去均值，去趋势，去仪器响应，输出速度 单位nm/s 

CALL cut_data(sdb, iev, ist, t0, tlen) # 将temp.sac截取，写到cut.sac里，删除temp.sac
# cut.sac 头文件的参考时间 2000年第一天 b = 0.0 这个头文件不知道搞什么鬼
INQUIRE(FILE=str_temp, EXIST=alive)     # 这里的str_temp是日期路径，INQUIRE也可以判断目录是否存在，不存在新建一个
把截取好的cut.sac写入tarfolder/DATA_VEL/年/月/日期/下 文件名:eg:BU.BDH.LHZ.SAC
把数据文件都处理完，删除CALL SYSTEM('rm -rf '//TRIM(tarfolder)//'/DATA') # 备份文件，卸磨杀驴

part 03  # line number 310
调整相位，带通滤波，反变化，写入 tarfolder/DATA/年/月/日期下
*******************************************************************************************

CALL SYSTEM('rm -rf sac.lst')  # part 03 会生成一个sac.lst，这里删除以前的sac.lst ！ rm 不存在的东西不会报错
OPEN(UNIT=19, FILE='list_sac.tmp', STATUS='REPLACE', ACTION='WRITE') # 以写的方式打开 list_sac.tmp
for year in `ls DATA_VEL` # 循环 DATA_VEL 文件夹下的年文件夹，赋值给year
for month in  `ls DATA_VEL/$year`  # 循环月文件夹
循环天文件夹
循环每个文件，将文件名以追加的方式写入sac.lst    # ls ', TRIM(tarfolder)//'/DATA_VEL/$year/$month/$day/* >> sac.lst  这种*号表示方法，显示的带路径的文件  
执行shell，执行上面的操作

OPEN sac.lst    # line 335
读取 sac.lst，也就是part02处理过的SAC文件的路径，赋值给str_temp # 循环每一个SAC文件
 读SAC文件，nlen是记录点数，dt采样的时间间隔，frac时间的残差(不在时间的点上的部分,小于0.5*dt)
 CALL frac_filter4(f1, f2, f3, f4, npow, dt, nlen, frac, seis_data, nerr)    #  line 369 MODULE Main_Proc
 # 对seis_data进行相位调整（因为时间相差frac)，然后带通滤波，然后反傅立叶变化，将处理完的数据赋给seis_data
 str_temp 赋值，是TRIM(tarfolder)//'/DATA/'/年/月/日/ # 天数路径 # 这个DATA文件夹里就是之前备份的原始文件，后来被卸磨杀驴了
 如果不存在str_temp，新建文件夹
 str_temp = TRIM(str_temp)//'/'//TRIM(strArray(nstrArray)) # 单个的文件
 CALL sacio_writesac(TRIM(str_temp), sac_head, seis_data, nerr) # 将 part03处理完的数据写到str_temp中 
end DO
CALL SYSTEM('rm -rf list_sac.tmp sac.lst')  # 删除 临时文件
 
part 04 # line 417



#################################################################################################
MODULE Main_Proc
INCLUDE 'fftw3.f03'
用fftw3，不用编译fftw3.f03，只需要执行的时候加一句-lfftw3

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE remove_RESP(sdb, iev, ist, f1, f2, f3, f4)
SAC文件去均值，去趋势，去仪器响应，输出的sac记录的是速度
判断f1,f2,f3,f4是否满足要求(f4>f3>f2>f1>0)
把SAC文件复制到tmp.sac
将命令写入sac_resp_bp.txt
对tmp.sac 去均值，去趋势，去仪器响应
'transfer from polezero subtype PZfiles/'TRIM(sdb%st(ist)%n_name)//'..LHZ.PZ to vel freq ',f1, f2, f3, f4
从SAC PZ 仪器响应文件里去仪器响应，vel表示去仪器响应得到速度，freq是去仪器响应时，带通滤波
乘以10的9次方
transfer命令，详情看https://seisman.github.io/SAC_Docs_zh/commands/transfer/
WRITE(18, "(A)") 'w over' # w over 用内存里的文件覆盖磁盘里的文件

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE cut_data(sdb, iev, ist, t0, tlen)
# t0 是开始时刻(相对文件时间) tlen是数据时间长度，单位s
tend = t0 + tlen
dt=delta N=nrec，数据长度 Nlen截取后的长度
trb = sdb%rec(iev,ist)%t0 - sdb%ev(iev)%t0  # 数据起点的时间-文件时间(参考时间)
tre = trb + (N-1)*dt           # 数据的终点(未截取的) - 文件时间(参考时间)
判断选取的时间是否合适，不合适就返回
合适的话,CALL sacio_readsac('tmp.sac', shd, seis_data, nerr)  # shd：头  seis_data：数据
Ngap = INT((t0-trb)/dt+0.5) # 要跳过的点数,四舍五入
shd%npts = Nlen  # 数据长度，因为写数据命令会根据npts决定数据长度
参考时间:year:2000 jday:1 时分秒毫秒都是0 b = 0.0
shd%user1 = REAL(sdb%rec(iev,ist)%frac)
CALL sacio_writesac('cut.sac', shd, seis_data(Ngap+1:), nerr) # 将截取完的数据保存到cut.sac
删除temp.sac文件
# 总觉得头文件的参考时间和b值不太对

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE frac_filter4(f1, f2, f3, f4, npow, dt, n, frac, seis_data, nerr) #  n 是数据长度
# 对seis_data 数据进行进行相位移动(frac)，再进行滤波
# 有改动，1.傅立叶变化，正变化改成了FFTW_FORWARD，反变化变成了FFTW_BACKWARD(和原来相反) 2.相位移动原来是1：Nfft/2，我改成了Nk(Nfft/2+1),Nk是对称点，对应的pi;
# 3.sf(k) = sf(k) * CDEXP(-2*pi*ci*fs*frac*(k-1)) 乘以-2pi  4.给pi到2pi的数据，添加复共轭(关于Nk对称)，所以也不用将sf(1)=sf(1)/2,也不用在反傅立叶变化之后对s(k)*2

COMPLEX(DBL), ALLOCATABLE, DIMENSION(:) :: s, sf    # 数组长度为Nfft
TYPE(C_PTR) :: plan      USE, INTRINSIC :: ISO_C_BINDING  # F03标准的数据传递  C语言中的指针变量

Nfft = 2**MAX(INT(LOG(REAL(n))/LOG(2.0))+1, 13) # number of points for FFT 对应圆频率0到2pi 频率 0到1/dt ！为什么最小是2的13次方？ 
# fft的长度是2的n次方 2^(ln(n)/ln(2))=n 取整会导致频率点数高于时间点数  Nfft/2 < n <Nfft
fs = 1.0D0/(dt*Nfft)     # fs 频率间隔
s(k) = seis_data(k)     # 把地震记录赋给s(:)
# 对s做FFT,s必须是复数，s的长度是Nfft，不足的补零
plan = fftw_plan_dft_1d(Nfft, s, sf, FFTW_BACKWARD, FFTW_ESTIMATE)  # 接口的定义在fftw3.f03
# 创建变化方案,这里是FFTW_BACKWARD(+1)，我改成了FFTW_FORWARD(-1)

CALL fftw_execute_dft(plan, s, sf)  # fftw3.f03 subroutine fftw_execute_dft(p,in,out)
# 执行FFT
CALL fftw_destroy_plan(plan)  # 释放内存

IF (ABS(frac) > 0.05D0*dt) THEN  # 相位调整
sf(k) = sf(k) * CDEXP(ci*fs*frac*(k-1))  # 我推导的多了一个系数-2pi 原来计算到1,Nfft/2，我计算到了Nk = Nfft/2 + 1
sf后半部分，都置零(实部和虚部)
sf(Nk) = DCMPLX(DREAL(sf(Nk)), 0.0D0) # 矫正Nk点，对应的pi，复共轭对称点,虚部为零
CALL band_pass(f1, f2, f3, f4, fs, Nk, npow, sf) # 带通滤波，npow是滤波器参数，表示f1，f2之间的加余弦窗的次数，越大迭代的次数越多，靠近f2越陡
给pi到2pi添加复共轭
反傅立叶变化，然后s转化为seis_data # 1.FFTW_BACKWARD(原来是FORWARD) 2.s/Nfft才是seis_data

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE band_pass(f1, f2, f3, f4, fs, Nk, npow, sf)
f1 f2 f3 f4是滤波范围 fs是频率间隔 Nk是频率点数，只包括一半，1到Nfft/2+1 （0到pi，包括pi)
npow是滤波器参数，可以理解为滤波器的阶数，表示对过渡区域(f1,f2),操作的次数(1-cos((f-f1)/(f2-f1))) if f1<f<=f2
sf是频率序列  

pi = DATAN(1.0D0)*4.0D0   # DATAN = tan-1(反正切)  DATAN(1.0D0)=pi/4
sf(i) = sf(i) * alpha(i)   # 滤波系数  alpha(i) f<f1或f>f4,alpha=0; f在(f1,f2)或（f3，f4)之间，会逐渐从0到1；
npow，整数，加余弦窗的次数，越大，接近f2越陡












